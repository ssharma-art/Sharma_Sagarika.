import numpy as np

# ============================================================
# Step 2 â€“ Diffusion Simulation of Cu with Zn-Dependent Mobility
# ============================================================

# --- Load Step 1 data (Cu_init and Zn_mask) ---
data = np.load("step1_arrays.npz")
Cu = data["Cu_init"].copy()      # Initial Cu concentration
Zn_mask = data["Zn_mask"]        # 1 = Zn, 0 = no Zn

N = Cu.shape[0]                  # Grid size
steps = 200                      # Number of diffusion steps

# Diffusion coefficients
D0 = 0.1                         # Base diffusion coefficient
D = np.where(Zn_mask == 1, D0 * 0.25, D0)   # Zn suppresses mobility

# To store history (optional)
Cu_history = np.zeros((steps, N, N))
Cu_history[0] = Cu.copy()

# ============================================================
# Define Laplacian operator
# ============================================================
def laplacian(arr):
    """Compute 2D Laplacian using periodic boundary conditions."""
    return (
        np.roll(arr, 1, axis=0) +
        np.roll(arr, -1, axis=0) +
        np.roll(arr, 1, axis=1) +
        np.roll(arr, -1, axis=1) -
        4 * arr
    )

# ============================================================
# Diffusion time-stepping loop
# ============================================================
for t in range(1, steps):
    Cu = Cu + D * laplacian(Cu)
    Cu_history[t] = Cu.copy()

# ============================================================
# Save results for Step 3
# ============================================================
np.savez(
    "step2_results.npz",
    Cu_final=Cu,
    Cu_history=Cu_history,
    Zn_mask=Zn_mask,
    steps=steps,
    grid_size=N
)

print("Step 2 complete!")
print("Diffusion simulation finished.")
print("Saved results to: step2_results.npz")
